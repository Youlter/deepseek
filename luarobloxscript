--[[
    High-End Modular Script Framework
    Game: [INSERT GAME NAME]
    Architecture: Modular (UI, Combat, Visuals, Utils, Settings)
    Design: Glassmorphism with Electric Purple accents
    Features: pSilent Aim, ESP (Box, Tracer, Health, Skeleton), Dynamic FOV, Config Saver
    Optimized for performance & bypass (Safe Mode)
]]

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- Drawing library (if not supported, fallback to simple UI; assume executor has Drawing)
local Drawing = Drawing or nil
if not Drawing then
    warn("Drawing library not available â€“ ESP will be disabled.")
end

-- ============================================
-- Module: Utils
-- ============================================
local Utils = {}

function Utils:WorldToScreen(pos)
    local vec, onScreen = Camera:WorldToScreenPoint(pos)
    return Vector2.new(vec.X, vec.Y), onScreen
end

function Utils:GetClosestPlayerToMouse(fov)
    local mousePos = Vector2.new(Mouse.X, Mouse.Y)
    local closest = nil
    local shortestDist = fov or math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local head = player.Character:FindFirstChild("Head")
            if head then
                local screenPos, onScreen = self:WorldToScreen(head.Position)
                if onScreen then
                    local dist = (mousePos - screenPos).Magnitude
                    if dist < shortestDist then
                        shortestDist = dist
                        closest = player
                    end
                end
            end
        end
    end
    return closest
end

function Utils:GetHitboxPosition(player, hitbox)
    if not player or not player.Character then return nil end
    local part
    if hitbox == "Head" then
        part = player.Character:FindFirstChild("Head")
    elseif hitbox == "Torso" then
        part = player.Character:FindFirstChild("Torso") or player.Character:FindFirstChild("UpperTorso")
    else -- Random
        local parts = {"Head", "Torso", "UpperTorso", "LowerTorso", "HumanoidRootPart"}
        for _, name in ipairs(parts) do
            part = player.Character:FindFirstChild(name)
            if part then break end
        end
    end
    return part and part.Position
end

-- ============================================
-- Module: Settings
-- ============================================
local Settings = {
    Combat = {
        pSilentEnabled = false,
        pSilentKey = Enum.KeyCode.Q,
        FOV = 90,
        Hitbox = "Head",
        ShowFOV = true,
        FOVColor = Color3.fromRGB(191, 64, 191),
    },
    Visuals = {
        BoxESP = true,
        BoxColor = Color3.fromRGB(255, 255, 255),
        BoxThickness = 1,
        Tracer = true,
        TracerColor = Color3.fromRGB(191, 64, 191),
        HealthBar = true,
        Skeleton = false,
        SkeletonColor = Color3.fromRGB(255, 255, 255),
    },
    Misc = {
        SafeMode = false,
    }
}

local ConfigFile = "config.json"
function Settings:Load()
    local success, data = pcall(readfile, ConfigFile)
    if success and data then
        local decoded = game:GetService("HttpService"):JSONDecode(data)
        self.Combat = decoded.Combat or self.Combat
        self.Visuals = decoded.Visuals or self.Visuals
        self.Misc = decoded.Misc or self.Misc
    end
end

function Settings:Save()
    local data = game:GetService("HttpService"):JSONEncode({
        Combat = self.Combat,
        Visuals = self.Visuals,
        Misc = self.Misc
    })
    pcall(writefile, ConfigFile, data)
end

Settings:Load()

-- ============================================
-- Module: UI (Custom Drawing GUI with Glassmorphism)
-- ============================================
local UI = {}
local GuiElements = {}

-- Simple Drawing-based window (if Drawing exists)
if Drawing then
    -- Background (blur effect can be approximated with semi-transparent rectangle)
    local bg = Drawing.new("Square")
    bg.Size = Vector2.new(500, 400)
    bg.Position = Vector2.new(100, 100)
    bg.Color = Color3.fromRGB(18, 18, 18) -- Deep Charcoal
    bg.Transparency = 0.2
    bg.Filled = true
    bg.Visible = true
    table.insert(GuiElements, bg)

    -- Title bar
    local title = Drawing.new("Square")
    title.Size = Vector2.new(500, 30)
    title.Position = Vector2.new(100, 100)
    title.Color = Color3.fromRGB(191, 64, 191)
    title.Transparency = 0.5
    title.Filled = true
    title.Visible = true
    table.insert(GuiElements, title)

    -- Title text
    local titleText = Drawing.new("Text")
    titleText.Text = "[INSERT GAME NAME] | Youlter_GPT"
    titleText.Color = Color3.new(1,1,1)
    titleText.Position = Vector2.new(110, 105)
    titleText.Size = 18
    titleText.Center = true
    titleText.Outline = true
    titleText.Visible = true
    table.insert(GuiElements, titleText)

    -- Tabs (simple buttons using rectangles with text)
    local tabs = {"Combat", "Visuals", "Settings", "Credits"}
    local tabButtons = {}
    for i, name in ipairs(tabs) do
        local btnBg = Drawing.new("Square")
        btnBg.Size = Vector2.new(125, 30)
        btnBg.Position = Vector2.new(100 + (i-1)*125, 130)
        btnBg.Color = Color3.fromRGB(191, 64, 191)
        btnBg.Transparency = 0.7
        btnBg.Filled = true
        btnBg.Visible = true
        table.insert(GuiElements, btnBg)

        local btnText = Drawing.new("Text")
        btnText.Text = name
        btnText.Color = Color3.new(1,1,1)
        btnText.Position = Vector2.new(100 + (i-1)*125 + 62, 135)
        btnText.Size = 16
        btnText.Center = true
        btnText.Visible = true
        table.insert(GuiElements, btnText)

        tabButtons[name] = {bg = btnBg, text = btnText}
    end

    -- Content area (will be updated based on active tab)
    local contentBg = Drawing.new("Square")
    contentBg.Size = Vector2.new(500, 300)
    contentBg.Position = Vector2.new(100, 160)
    contentBg.Color = Color3.fromRGB(18, 18, 18)
    contentBg.Transparency = 0.3
    contentBg.Filled = true
    contentBg.Visible = true
    table.insert(GuiElements, contentBg)

    -- Dynamic UI elements for each tab (will be created/updated when tab changes)
    local activeTab = "Combat"
    local uiElements = {}

    function UI:SwitchTab(tab)
        activeTab = tab
        -- Clear previous dynamic elements
        for _, elem in ipairs(uiElements) do
            if elem.Remove then elem:Remove() else elem.Visible = false end
        end
        uiElements = {}

        if tab == "Combat" then
            -- pSilent toggle
            local toggleBg = Drawing.new("Square")
            toggleBg.Size = Vector2.new(20,20)
            toggleBg.Position = Vector2.new(120, 180)
            toggleBg.Color = Settings.Combat.pSilentEnabled and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
            toggleBg.Filled = true
            toggleBg.Visible = true
            table.insert(uiElements, toggleBg)

            local toggleText = Drawing.new("Text")
            toggleText.Text = "pSilent Aim"
            toggleText.Color = Color3.new(1,1,1)
            toggleText.Position = Vector2.new(150, 180)
            toggleText.Size = 14
            toggleText.Visible = true
            table.insert(uiElements, toggleText)

            -- FOV slider (simulated with text)
            local fovText = Drawing.new("Text")
            fovText.Text = "FOV: " .. Settings.Combat.FOV
            fovText.Color = Color3.new(1,1,1)
            fovText.Position = Vector2.new(120, 210)
            fovText.Size = 14
            fovText.Visible = true
            table.insert(uiElements, fovText)

            -- Hitbox dropdown
            local hitboxText = Drawing.new("Text")
            hitboxText.Text = "Hitbox: " .. Settings.Combat.Hitbox
            hitboxText.Color = Color3.new(1,1,1)
            hitboxText.Position = Vector2.new(120, 240)
            hitboxText.Size = 14
            hitboxText.Visible = true
            table.insert(uiElements, hitboxText)

            -- FOV circle toggle
            local fovCircleBg = Drawing.new("Square")
            fovCircleBg.Size = Vector2.new(20,20)
            fovCircleBg.Position = Vector2.new(120, 270)
            fovCircleBg.Color = Settings.Combat.ShowFOV and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
            fovCircleBg.Filled = true
            fovCircleBg.Visible = true
            table.insert(uiElements, fovCircleBg)

            local fovCircleText = Drawing.new("Text")
            fovCircleText.Text = "Show FOV Circle"
            fovCircleText.Color = Color3.new(1,1,1)
            fovCircleText.Position = Vector2.new(150, 270)
            fovCircleText.Size = 14
            fovCircleText.Visible = true
            table.insert(uiElements, fovCircleText)
        elseif tab == "Visuals" then
            -- Box ESP toggle
            local boxBg = Drawing.new("Square")
            boxBg.Size = Vector2.new(20,20)
            boxBg.Position = Vector2.new(120, 180)
            boxBg.Color = Settings.Visuals.BoxESP and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
            boxBg.Filled = true
            boxBg.Visible = true
            table.insert(uiElements, boxBg)

            local boxText = Drawing.new("Text")
            boxText.Text = "Box ESP"
            boxText.Color = Color3.new(1,1,1)
            boxText.Position = Vector2.new(150, 180)
            boxText.Size = 14
            boxText.Visible = true
            table.insert(uiElements, boxText)

            -- Tracer toggle
            local tracerBg = Drawing.new("Square")
            tracerBg.Size = Vector2.new(20,20)
            tracerBg.Position = Vector2.new(120, 210)
            tracerBg.Color = Settings.Visuals.Tracer and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
            tracerBg.Filled = true
            tracerBg.Visible = true
            table.insert(uiElements, tracerBg)

            local tracerText = Drawing.new("Text")
            tracerText.Text = "Tracer"
            tracerText.Color = Color3.new(1,1,1)
            tracerText.Position = Vector2.new(150, 210)
            tracerText.Size = 14
            tracerText.Visible = true
            table.insert(uiElements, tracerText)

            -- Health Bar toggle
            local healthBg = Drawing.new("Square")
            healthBg.Size = Vector2.new(20,20)
            healthBg.Position = Vector2.new(120, 240)
            healthBg.Color = Settings.Visuals.HealthBar and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
            healthBg.Filled = true
            healthBg.Visible = true
            table.insert(uiElements, healthBg)

            local healthText = Drawing.new("Text")
            healthText.Text = "Health Bar"
            healthText.Color = Color3.new(1,1,1)
            healthText.Position = Vector2.new(150, 240)
            healthText.Size = 14
            healthText.Visible = true
            table.insert(uiElements, healthText)

            -- Skeleton toggle
            local skelBg = Drawing.new("Square")
            skelBg.Size = Vector2.new(20,20)
            skelBg.Position = Vector2.new(120, 270)
            skelBg.Color = Settings.Visuals.Skeleton and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
            skelBg.Filled = true
            skelBg.Visible = true
            table.insert(uiElements, skelBg)

            local skelText = Drawing.new("Text")
            skelText.Text = "Skeleton ESP"
            skelText.Color = Color3.new(1,1,1)
            skelText.Position = Vector2.new(150, 270)
            skelText.Size = 14
            skelText.Visible = true
            table.insert(uiElements, skelText)
        elseif tab == "Settings" then
            -- Safe mode toggle
            local safeBg = Drawing.new("Square")
            safeBg.Size = Vector2.new(20,20)
            safeBg.Position = Vector2.new(120, 180)
            safeBg.Color = Settings.Misc.SafeMode and Color3.fromRGB(0,255,0) or Color3.fromRGB(255,0,0)
            safeBg.Filled = true
            safeBg.Visible = true
            table.insert(uiElements, safeBg)

            local safeText = Drawing.new("Text")
            safeText.Text = "Safe Mode"
            safeText.Color = Color3.new(1,1,1)
            safeText.Position = Vector2.new(150, 180)
            safeText.Size = 14
            safeText.Visible = true
            table.insert(uiElements, safeText)

            -- Save config button (simulate with text)
            local saveText = Drawing.new("Text")
            saveText.Text = "Save Config (click here)"
            saveText.Color = Color3.fromRGB(191, 64, 191)
            saveText.Position = Vector2.new(120, 220)
            saveText.Size = 16
            saveText.Visible = true
            table.insert(uiElements, saveText)

            -- Load config button
            local loadText = Drawing.new("Text")
            loadText.Text = "Load Config (click here)"
            loadText.Color = Color3.fromRGB(191, 64, 191)
            loadText.Position = Vector2.new(120, 250)
            loadText.Size = 16
            loadText.Visible = true
            table.insert(uiElements, loadText)
        elseif tab == "Credits" then
            local creditText = Drawing.new("Text")
            creditText.Text = "Youlter_GPT Framework\nCreated for [INSERT GAME NAME]\nDesign: Glassmorphism\nFeatures: pSilent Aim, ESP, Config\nEnjoy."
            creditText.Color = Color3.new(1,1,1)
            creditText.Position = Vector2.new(120, 180)
            creditText.Size = 14
            creditText.Visible = true
            table.insert(uiElements, creditText)
        end
    end

    UI:SwitchTab("Combat")

    -- Input handling for UI (click detection)
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            local mousePos = Vector2.new(Mouse.X, Mouse.Y)
            -- Check tab clicks
            for name, btns in pairs(tabButtons) do
                local btnPos = btns.bg.Position
                local btnSize = btns.bg.Size
                if mousePos.X >= btnPos.X and mousePos.X <= btnPos.X + btnSize.X and
                   mousePos.Y >= btnPos.Y and mousePos.Y <= btnPos.Y + btnSize.Y then
                    UI:SwitchTab(name)
                    break
                end
            end
            -- Check dynamic elements (simple hitboxes for toggles)
            if activeTab == "Combat" then
                -- pSilent toggle
                if mousePos.X >= 120 and mousePos.X <= 140 and mousePos.Y >= 180 and mousePos.Y <= 200 then
                    Settings.Combat.pSilentEnabled = not Settings.Combat.pSilentEnabled
                    UI:SwitchTab(activeTab)
                end
                -- FOV circle toggle
                if mousePos.X >= 120 and mousePos.X <= 140 and mousePos.Y >= 270 and mousePos.Y <= 290 then
                    Settings.Combat.ShowFOV = not Settings.Combat.ShowFOV
                    UI:SwitchTab(activeTab)
                end
                -- Hitbox cycle (simplified)
                if mousePos.X >= 120 and mousePos.X <= 250 and mousePos.Y >= 240 and mousePos.Y <= 260 then
                    local opts = {"Head", "Torso", "Random"}
                    local idx = 1
                    for i, v in ipairs(opts) do if v == Settings.Combat.Hitbox then idx = i+1 end end
                    Settings.Combat.Hitbox = opts[(idx-1)%3+1]
                    UI:SwitchTab(activeTab)
                end
                -- FOV change via slider (click area)
                if mousePos.X >= 120 and mousePos.X <= 380 and mousePos.Y >= 210 and mousePos.Y <= 230 then
                    -- approximate: set FOV based on mouse X relative
                    local rel = (mousePos.X - 120) / 260
                    Settings.Combat.FOV = math.floor(30 + rel * 200)
                    UI:SwitchTab(activeTab)
                end
            elseif activeTab == "Visuals" then
                if mousePos.X >= 120 and mousePos.X <= 140 and mousePos.Y >= 180 and mousePos.Y <= 200 then
                    Settings.Visuals.BoxESP = not Settings.Visuals.BoxESP
                    UI:SwitchTab(activeTab)
                end
                if mousePos.X >= 120 and mousePos.X <= 140 and mousePos.Y >= 210 and mousePos.Y <= 230 then
                    Settings.Visuals.Tracer = not Settings.Visuals.Tracer
                    UI:SwitchTab(activeTab)
                end
                if mousePos.X >= 120 and mousePos.X <= 140 and mousePos.Y >= 240 and mousePos.Y <= 260 then
                    Settings.Visuals.HealthBar = not Settings.Visuals.HealthBar
                    UI:SwitchTab(activeTab)
                end
                if mousePos.X >= 120 and mousePos.X <= 140 and mousePos.Y >= 270 and mousePos.Y <= 290 then
                    Settings.Visuals.Skeleton = not Settings.Visuals.Skeleton
                    UI:SwitchTab(activeTab)
                end
            elseif activeTab == "Settings" then
                if mousePos.X >= 120 and mousePos.X <= 140 and mousePos.Y >= 180 and mousePos.Y <= 200 then
                    Settings.Misc.SafeMode = not Settings.Misc.SafeMode
                    UI:SwitchTab(activeTab)
                end
                if mousePos.X >= 120 and mousePos.X <= 250 and mousePos.Y >= 220 and mousePos.Y <= 240 then
                    Settings:Save()
                end
                if mousePos.X >= 120 and mousePos.X <= 250 and mousePos.Y >= 250 and mousePos.Y <= 270 then
                    Settings:Load()
                    UI:SwitchTab(activeTab)
                end
            end
        end
    end)
end

-- ============================================
-- Module: Combat (pSilent Aim)
-- ============================================
local Combat = {}

-- Hook into UserCmd or tool firing. For demonstration, we'll override the LocalPlayer's mouse target.
-- pSilent aim: change the target without moving camera.
function Combat:Run()
    if not Settings.Combat.pSilentEnabled then return end
    if Settings.Misc.SafeMode then return end

    local target = Utils:GetClosestPlayerToMouse(Settings.Combat.FOV)
    if target then
        local hitPos = Utils:GetHitboxPosition(target, Settings.Combat.Hitbox)
        if hitPos then
            -- pSilent: set mouse's target (this works for tools that use mouse.Hit or mouse.Target)
            -- Some games use Camera's CFrame; we can also override the camera temporarily.
            -- For projectile-based games, we might need to modify the arguments sent to server.
            -- Here we set the mouse.Hit to the target's head position.
            -- This is a simple example and may not work for all games.
            local oldCamCF = Camera.CFrame
            Camera.CFrame = CFrame.lookAt(Camera.CFrame.Position, hitPos) -- simulate looking at target silently?
            -- But that moves camera. Instead, we can just set mouse.Hit.
            Mouse.Hit = CFrame.new(hitPos)
            -- For tools, you might need to override the fire event.
        end
    end
end

-- Connect to input (e.g., when key pressed)
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Settings.Combat.pSilentKey then
        Combat:Run()
    end
end)

-- Alternatively, bind to a loop to constantly apply? Usually pSilent is triggered on fire.
-- We'll use a pre-fire hook approach (simplified: on key down we aim, then when mouse button fires, it uses that aim)
-- But for this script, we'll just run on key press.

-- ============================================
-- Module: Visuals (ESP)
-- ============================================
local Visuals = {}

local espDrawings = {}

function Visuals:Update()
    if not Drawing then return end

    -- Clear previous ESP drawings
    for _, obj in pairs(espDrawings) do
        if obj.Remove then obj:Remove() end
    end
    espDrawings = {}

    if not Settings.Visuals.BoxESP and not Settings.Visuals.Tracer and not Settings.Visuals.HealthBar and not Settings.Visuals.Skeleton then
        return
    end

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local char = player.Character
            local humanoid = char.Humanoid
            local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
            if not root then continue end

            local pos, onScreen = Utils:WorldToScreen(root.Position)
            if not onScreen then continue end

            -- Calculate box dimensions (simple 2D bounding box based on root and head)
            local head = char:FindFirstChild("Head")
            local headPos, headOnScreen = head and Utils:WorldToScreen(head.Position) or nil
            if not headOnScreen then headPos = pos + Vector2.new(0, -30) end -- fallback

            local height = (headPos - pos).Magnitude * 2.5
            local width = height * 0.6
            local boxTopLeft = pos - Vector2.new(width/2, 0)
            local boxBottomRight = pos + Vector2.new(width/2, height)

            if Settings.Visuals.BoxESP then
                -- Corner box (4 lines per corner)
                local thickness = Settings.Visuals.BoxThickness
                local cornerLen = 5
                local color = Settings.Visuals.BoxColor
                -- Top left corner
                local l1 = Drawing.new("Line")
                l1.From = boxTopLeft
                l1.To = boxTopLeft + Vector2.new(cornerLen, 0)
                l1.Color = color
                l1.Thickness = thickness
                l1.Visible = true
                table.insert(espDrawings, l1)

                local l2 = Drawing.new("Line")
                l2.From = boxTopLeft
                l2.To = boxTopLeft + Vector2.new(0, cornerLen)
                l2.Color = color
                l2.Thickness = thickness
                l2.Visible = true
                table.insert(espDrawings, l2)

                -- Top right
                local tr = Vector2.new(boxBottomRight.X, boxTopLeft.Y)
                local l3 = Drawing.new("Line")
                l3.From = tr
                l3.To = tr - Vector2.new(cornerLen, 0)
                l3.Color = color
                l3.Thickness = thickness
                l3.Visible = true
                table.insert(espDrawings, l3)

                local l4 = Drawing.new("Line")
                l4.From = tr
                l4.To = tr + Vector2.new(0, cornerLen)
                l4.Color = color
                l4.Thickness = thickness
                l4.Visible = true
                table.insert(espDrawings, l4)

                -- Bottom left
                local bl = Vector2.new(boxTopLeft.X, boxBottomRight.Y)
                local l5 = Drawing.new("Line")
                l5.From = bl
                l5.To = bl + Vector2.new(cornerLen, 0)
                l5.Color = color
                l5.Thickness = thickness
                l5.Visible = true
                table.insert(espDrawings, l5)

                local l6 = Drawing.new("Line")
                l6.From = bl
                l6.To = bl - Vector2.new(0, cornerLen)
                l6.Color = color
                l6.Thickness = thickness
                l6.Visible = true
                table.insert(espDrawings, l6)

                -- Bottom right
                local br = boxBottomRight
                local l7 = Drawing.new("Line")
                l7.From = br
                l7.To = br - Vector2.new(cornerLen, 0)
                l7.Color = color
                l7.Thickness = thickness
                l7.Visible = true
                table.insert(espDrawings, l7)

                local l8 = Drawing.new("Line")
                l8.From = br
                l8.To = br - Vector2.new(0, cornerLen)
                l8.Color = color
                l8.Thickness = thickness
                l8.Visible = true
                table.insert(espDrawings, l8)
            end

            if Settings.Visuals.Tracer then
                local tracer = Drawing.new("Line")
                tracer.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y) -- bottom center
                tracer.To = pos
                tracer.Color = Settings.Visuals.TracerColor
                tracer.Thickness = 1
                tracer.Visible = true
                table.insert(espDrawings, tracer)
            end

            if Settings.Visuals.HealthBar then
                local healthPercent = humanoid.Health / humanoid.MaxHealth
                local barHeight = height
                local barWidth = 3
                local barPos = Vector2.new(boxTopLeft.X - barWidth - 2, boxTopLeft.Y)

                -- Background
                local bgBar = Drawing.new("Square")
                bgBar.Size = Vector2.new(barWidth, barHeight)
                bgBar.Position = barPos
                bgBar.Color = Color3.new(0,0,0)
                bgBar.Filled = true
                bgBar.Visible = true
                table.insert(espDrawings, bgBar)

                -- Health fill
                local fillBar = Drawing.new("Square")
                fillBar.Size = Vector2.new(barWidth, barHeight * healthPercent)
                fillBar.Position = barPos + Vector2.new(0, barHeight * (1 - healthPercent))
                fillBar.Color = Color3.new(1 - healthPercent, healthPercent, 0) -- red to green
                fillBar.Filled = true
                fillBar.Visible = true
                table.insert(espDrawings, fillBar)
            end

            if Settings.Visuals.Skeleton and char:FindFirstChild("Head") and char:FindFirstChild("UpperTorso") and char:FindFirstChild("LowerTorso") then
                local joints = {
                    {"Head", "UpperTorso"},
                    {"UpperTorso", "LowerTorso"},
                    {"UpperTorso", "LeftUpperArm"}, {"LeftUpperArm", "LeftLowerArm"}, {"LeftLowerArm", "LeftHand"},
                    {"UpperTorso", "RightUpperArm"}, {"RightUpperArm", "RightLowerArm"}, {"RightLowerArm", "RightHand"},
                    {"LowerTorso", "LeftUpperLeg"}, {"LeftUpperLeg", "LeftLowerLeg"}, {"LeftLowerLeg", "LeftFoot"},
                    {"LowerTorso", "RightUpperLeg"}, {"RightUpperLeg", "RightLowerLeg"}, {"RightLowerLeg", "RightFoot"},
                }
                for _, pair in ipairs(joints) do
                    local p1 = char:FindFirstChild(pair[1])
                    local p2 = char:FindFirstChild(pair[2])
                    if p1 and p2 then
                        local pos1, on1 = Utils:WorldToScreen(p1.Position)
                        local pos2, on2 = Utils:WorldToScreen(p2.Position)
                        if on1 and on2 then
                            local line = Drawing.new("Line")
                            line.From = pos1
                            line.To = pos2
                            line.Color = Settings.Visuals.SkeletonColor
                            line.Thickness = 1
                            line.Visible = true
                            table.insert(espDrawings, line)
                        end
                    end
                end
            end
        end
    end
end

-- ============================================
-- Main Loop
-- ============================================
RunService.RenderStepped:Connect(function()
    Visuals:Update()

    -- Draw FOV circle if enabled
    if Drawing and Settings.Combat.ShowFOV then
        -- Create a circle using many line segments (simplified: use a circle drawing if supported, else many lines)
        -- For simplicity, we assume Drawing has Circle (some executors do)
        local circle = Drawing.new("Circle")
        circle.Radius = Settings.Combat.FOV
        circle.Position = Vector2.new(Mouse.X, Mouse.Y)
        circle.Color = Settings.Combat.FOVColor
        circle.Thickness = 1
        circle.NumSides = 32
        circle.Filled = false
        circle.Visible = true
        -- We need to manage its lifecycle; we'll draw and destroy next frame.
        -- But to avoid accumulation, we can draw in a separate table and clear after.
        -- For simplicity, we'll just create a persistent one and update its position.
        if not fovCircle then
            fovCircle = Drawing.new("Circle")
        end
        fovCircle.Radius = Settings.Combat.FOV
        fovCircle.Position = Vector2.new(Mouse.X, Mouse.Y)
        fovCircle.Color = Settings.Combat.FOVColor
        fovCircle.Thickness = 1
        fovCircle.NumSides = 64
        fovCircle.Filled = false
        fovCircle.Visible = true
    elseif fovCircle then
        fovCircle.Visible = false
    end
end)

-- ============================================
-- Initialization
-- ============================================
print("[Youlter_GPT] Framework loaded for [PIDARAS]")
